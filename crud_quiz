In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?
answer: console.rb
Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
answer: in the save method in the Class file
Q3. In console.rb, which lines modify the database?
answer: property1.save()
Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
answer: SQL generates/assigns the ID numbers

Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?
answer: in the Save method
Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?
answer: for security purposes (SQL injection)

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
answer: class methods don't require an instance to be present, because they return all instances by default.

Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?
answer: array
Q9. Why do we use prepared statements when performing database operations?
answer: to prevent SQL injections

Extension Questions
Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?
answer: array
Q11. What are their return values?
answer: 
